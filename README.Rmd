---
title: "README"
author: "Daniel Enns"
date: "2024-10-17"
output:
  github_document: default
always_allow_html: true
bibliography: references.bib
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(warning = FALSE)
```

# Study outline

Freshwater ecosystems exists in very heterogenous landscapes, including not only natural, but also anthropogenic "spatial features"[@carlisle2008; @marzin2012; @murphy2005]. Can these features, like barriers, wastewater treatment plants, road & railroad crossings, etc. explain the ecological status of the freshwater fauna? In this study, we try to answer this question combining various spatial data sets and utilizing machine learning algorithms [@dedman2015; @elith2008; @he√ü2023; @yu2020].

# Methods

```{r load_libraries_data, include=FALSE}
library(readxl)
library(tidyverse)
library(stars)
library(sf)
library(sfnetworks)
library(tidygraph)
library(SSN2)
library(SSNbler)
library(riverdist)
library(rivernet)
library(geodata)
library(whitebox)
library(osmextract)
library(httr2)
library(tmap)
library(ggpubr)
library(gridExtra)

setwd("C:/Users/Daniel Enns/Documents/Promotion/MZB/Enns-et-al.-3/Data")

stream_net <- st_read("./stream_net/stream_net_rev.gpkg") %>% 
  select(geom, GESAMT, HP3, GEWKZ, ABS) %>% st_cast("LINESTRING") %>% 
  mutate(ABS = as.numeric(ABS))

mzb <- read_delim("./Bio_data/EQC_MZB.csv", delim = ";") %>% 
  mutate(EQC = factor(EQC)) %>% group_by(ID_SITE) %>% arrange(desc(YEAR)) %>% slice_head() %>% 
  st_as_sf(coords = c("UTM_EAST", "UTM_NORTH"), crs = st_crs(25832))
mzb <- cbind(mzb, stream_net[st_nearest_feature(mzb, stream_net),]) %>% select(-geom)

ws <- read_stars("./DEM/watersheds.tif") %>% st_as_sf(as_points = F, merge = T)
```

## 1. Combining Spatial Data

### 1.1 Point features

For the spatial analysis all necessary shape and raster files are projected into EPSG 25832.

Highway and railroad networks can be read in from OpenStreetMap pbf files via the `osmextract` package. These can be intersected with the stream network to create point features. In the osm highway and railroad networks each lane / track is represented as an individual line feature, so that multiple crossings are present in locations with high lane / track density.

``` r
# Extract highway and railroad networks
transport_net <- oe_read("./hessen-latest.osm.pbf", extra_tags = "railway") %>%
  filter(highway == "motorway" | railway == "rail") %>% 
  st_transform(st_crs(stream_net))

# Intersect with stream network
crossings <- st_intersection(stream_net, transport_net) %>% 
  st_cast("POINT")
```

### 1.2 Watershed delineation

In order to delineate upstream watersheds for each bio sampling site the SRTM GL1 30m [@opentopography2013] digital elevation model will be used to extract flow accumulation and pointer grids, from which the watersheds are calculated. However, the delineation algorithms struggles in regions with low profiles (namely the Rhine basin), creating an inaccurate stream raster and watersheds. To improve accuracy, the existing stream network is burned into the DEM following these steps in QGIS:

1.  Reproject raster network to stream CRS (EPSG: 25832)

2.  dissolve the stream network

3.  Run the Grass r.carve algorithm with a stream width of 60 m, depth of 3 m and with no flat areas in direction of stream flow allowed (Note: the algorithm does not work on latitude-longitude CRS, see [r.carve GRASS GIS manual](https://grass.osgeo.org/grass-stable/manuals/r.carve.html))

The algorithm will take some time to run (approximately 1 hour and 18 minutes with an Intel core i7, 16 GB RAM). Finally, watersheds can be extracted using the `whitebox` package, following the instructions from [Gannon, 2024](https://vt-hydroinformatics.github.io/Quarto_Book/15-Watershed-Delineation-and-Analysis.html).

``` r
# Breach and fill pits in raster
wbt_breach_depressions_least_cost(
  dem = "./SRTMGL1_30m_2px_burned.tif", 
  output = "./srtm_breach.tif", 
  dist = 7,
  fill = T
)

# Create flow accumulation & pointer grids
wbt_d8_flow_accumulation(
  input = "./srtm_breach.tif",
  output = "./D8FA.tif"
)

wbt_d8_pointer(
  dem = "./srtm_breach.tif",
  output = "./D8pointer.tif"
)

# Extract streams
wbt_extract_streams(
  flow_accum = "./D8FA.tif",
  output = "./stream_raster.tif",
  threshold = 700
)

# Snap points to stream raster
wbt_jenson_snap_pour_points(
  pour_pts = "./MZB.shp",
  streams = "./stream_raster.tif",
  output = "./MZB_snap.shp",
  snap_dist = 300
)

# Delineate watersheds
wbt_watershed(
  d8_pntr = "./D8pointer.tif",
  pour_pts = "./MZB_snap.shp",
  output = "./watersheds.tif"
)
```

Figure 1 demonstrates the structure of the watersheds, which were build consecutively between multiple pour points.

```{r watershed_example_figure, echo=F, fig.cap="Figure 1: Example watershed. Each watershed is build consecutively between specified pourpoints."}

ws_stream <- stream_net %>% filter(str_starts(GEWKZ, "25872")) 
ws_bio <- mzb %>% filter(str_starts(GEWKZ, "25872"))
ws_clip <- ws %>% st_filter(ws_stream, predicate = st_touches) %>% filter(watersheds.tif != 812)

ggplot()+
  geom_sf(
    ws_clip,
    mapping = aes(fill = as.factor(watersheds.tif))
  )+
  geom_sf(
    ws_stream,
    mapping = aes(),
    linewidth = 1
  )+
  geom_sf(
    ws_bio,
    mapping = aes(),
    fill = "#FFFF00",
    colour = "#000000",
    size = 2,
    shape = 21
  )+
  scale_x_continuous(breaks = c(8.08, 8.12, 8.16, 8.20))+
  theme_bw()+
  theme(
    legend.position = "none"
  )
```

The created watershed raster can be read in and converted to polygon features, which subsequently be used to intersect the [CORINE Land Cover](https://land.copernicus.eu/en/products/corine-land-cover) polygons. The area of each intersection can be calculated using the `st_area()` function.

``` r
# Read in Watersheds and convert to polygon 
ws_poly <- read_stars("./watersheds.tif") %>% 
  st_as_sf(as_points = F, merge = T)

# Create dataframe with land cover areas
landcover_ws <- st_intersection(landcover, ws_poly) %>% 
  mutate(area = st_area(.)) %>% st_drop_geometry() %>% 
  as.data.frame() %>% filter(!is.na(type))

# Summarize land cover types in each watershed
landcover_sum <- landcover_ws %>% group_by(watersheds.tif, type) %>% 
  summarize(area = sum(area)) %>% 
  pivot_wider(names_from = type, values_from = area)

# Combine watersheds with summarized land cover
watersheds_lc <- left_join(ws_poly, landcover_sum, by = "watersheds.tif")
```

### 1.3 Network building

The Hessian stream network is a collection of 100 m long line segments, each containing a stream ID and a segment ID. The stream ID is designed in such a way, that it consecutively builds upon the ID of a previous stream segment, adding numbers to it, whenever the stream splits in upstream direction. The segment number increases towards the source of a stream (Fig. 2). Each 100 m segment already contains information on the in-stream and surrounding habitats structural quality (1 - pristine, 7 - completly altered).

```{r ID_example_figure,echo=FALSE , fig.cap = "Figure 2: Example of stream- and segment ID system. The segment number increases in the direction of the source. The stream ID of smaller confluence resembels always that of the bigger stream, in which it flows into, plus additional numbers."}

str_net_plot <- stream_net %>% filter(str_starts(GEWKZ, "24848292")) %>% 
  ggplot()+
  geom_sf(
    aes(
      col = GEWKZ
    ),
    linewidth = 4
  )+
  geom_sf_text(
    aes(label = ABS)
    )+
  labs(col = "stream ID")+
  theme_bw()+
  theme(
    axis.title = element_blank(),
    legend.position = "bottom"
  )
str_net_plot
```

The `sfnetwork` package provides many useful functions for network analysis and routing operations, where the main function `as_sfnetwork()` builds a network by connecting aligning nodes. An initial build reveals that many stream segments visually seem connected, but are separated from their nearest node or edge by a few meters. Thus, to build a useful network for routing the precision of the stream network `sf` object needs to be lowered (for more information see Details on `st_set_precision()` and `st_as_binary()` help page). To what precision to round depends, in general, on the maximum distance of dangling nodes and if the network can be build by connecting nodes with edges, or just by connecting nodes. The precision will be set to 70 meters (be aware of the object CRS units!).

In the resulting network, the right streams are connected (Fig. 3) and it can be used for routing operations. Performance of routing can be greatly increased by simplifying the network and removing pseudo-nodes (more info [here](https://luukvdmeer.github.io/sfnetworks/articles/sfn02_preprocess_clean.html)).

``` r
# Lower precision to 50 meters
str_net_50m <- st_set_precision(stream_net, set_units(70, "m"))

# Create sf_network object, simplify and smooth pseudo-nodes
network <- as_sfnetwork(str_net_50m) %>% convert(to_spatial_simple) %>% 
  convert(to_spatial_smooth)
```

```{r Precision_example_figure,echo=FALSE , fig.cap = "Figure 3: Example for how precision changes the connectedness of the network. The numbers indicate from which node a stream originates."}

net_1 <- stream_net %>% filter(str_starts(GEWKZ, "24848292")) %>% as_sfnetwork() %>% convert(to_spatial_simple) %>% convert(to_spatial_smooth)
net_2 <- stream_net %>% filter(str_starts(GEWKZ, "24848292")) %>% st_set_precision(0.1) %>% as_sfnetwork() %>% convert(to_spatial_simple) %>%
  convert(to_spatial_smooth)

edge_1 <- net_1 %>% st_as_sf("edges") %>% mutate(precision = "original precision")
edge_2 <- net_2 %>% st_as_sf("edges") %>% mutate(precision = "lowered precision")
nodes_1 <- net_1 %>% st_as_sf("nodes") %>% mutate(precision = "original precision")
nodes_2 <- net_2 %>% st_as_sf("nodes") %>% mutate(precision = "lowered precision")

edges <- rbind(edge_1, edge_2) %>% 
  mutate(precision = factor(precision, levels = c("original precision","lowered precision")))
nodes <- rbind(nodes_1, nodes_2) %>% 
  mutate(precision = factor(precision, levels = c("original precision","lowered precision")))

prec_plot <- edges %>% ggplot()+
  geom_sf(aes(color = as.factor(from)),
          linewidth = 2)+
  geom_sf(data = nodes, 
          color = "#000000", 
          size = 2) + 
  geom_sf_text(aes(label = from, 
                   color = as.factor(from)), 
               nudge_y = -100,
               nudge_x = -40,
               size = 7) + 
  facet_wrap(~precision, ncol = 2)+
  theme_bw()+ 
  theme(legend.position = "none", 
        axis.title = element_blank()
        )

prec_plot
```

Sampling sites and point stressors can be blend in as nodes into the created network.

``` r
# Blend in sampling sites, wastewater treatment plants and dams
network_blend <- st_network_blend(network, mzb) %>% st_network_blend(.,wwtp) %>% 
  st_network_blend(.,dams)
```

## 2. Spatial Data quantification

For the quantification of point- and polygon features and their attributes I wrote two custom functions, `st_shift()` and `upstream_summarize()`. The first function is required within the latter and shifts a set of point geometries a proportional distance towards another specified point. The `upstream_summarize()` function builds a sub-network from a given point to all its vertices (stream sources) and extracts the node data, from which it counts the number of specified nodes and sums up specified attribute values. Further, it can calculate the minimal network distance between the start point and a set of nodes specified by their IDs with the `IDs` argument. If no such nodes are present in the sub-network, `inf` values are returned. The function can sum up attribute values of provided polygons the following way: First, the set of nodes present in the sub-network are shifted towards their centroid by 0.1% of their length, to avoid including adjacent polygons. Then, it creates a filtering mask by selecting all polygons which are touched by the shifted nodes and fills in 'holes' in the set of polygons. By setting a threshold, the mask can be shrunken to avoid selecting adjacent polygons. This mask is finally used to select all polygons present in the sub-network, from which their specified attributes are summarized. The function contains the following set of arguments:

-   `net` : The complete network with blended in points of interest
-   `start` : Row name of node from which to rout upstream
-   `node_cols` : Names of attribute columns to summarize, present in nodes
-   `IDs` : ID columns for sets of nodes, which should be unique in each set
-   `area` : `sf` object with only polygon geometries
-   `area_cols` : names of attribute columns to summarize, present in `area`
-   `dist` : logical, should minimal distances between start and nodes, specified by `IDs`, be calculated?
-   `threshold` : Value (in polygon CRS units) by which the polygon mask should be shrunken.

Before this function can be used, the points from which the function should rout must be extracted as nodes from the network and their row name must be saved as a new column.

``` r
# Extract nodes of invertebrate sampling sites and add row names
mzb_nodes <- st_as_sf(network_blend, "nodes") %>% filter(!is.na(ID_SITE)) %>% 
  mutate(ID_NODE = row.names(nodes)[with(nodes, !is.na(ID_SITE))])
```

`upstream_summarize()` can be used in combination with rowwise() and mutate() to perform the action over multiple points. Depending on the number of nodes within the entire network, this task can take quite a lot of time.

``` r
# Apply upstream_summarize row-wise over all sampling site nodes 
mzb_data_complete <- mzb_nodes %>% rowwise() %>% 
  mutate(upstream_summarize(
    net = network_blend,
    start = ID_NODE,
    node_cols = c("population_equivalents", "dam_discharge"),
    IDs = c("ID_WWTP", "ID_DAMS"),
    area = ws_clc,
    area_cols = c("Agriculture", "Urban", "semi-Natural"),
    dist = T,
    threshold = 30)
    )
```

## 3. Modeling

## 4. Data availability

Data on WFD invertebrate sampling and the Hessian stream network were kindly provided by the Hessian state office for nature, environment and geology (HLNUG). Data on wastewater treatment plants, stormwater overflows are available for download from the [WRRL-viewer](https://wrrl.hessen.de/mapapps/resources/apps/wrrl/index.html?lang=de). Further, data on hydrological barriers are available from the [Amber Barrier Atlas](https://amber.international/european-barrier-atlas/). OpenStreetMap data can be downloaded as pbf files at [geofabrik](https://download.geofabrik.de/). CORINE land cover shapefiles and rasters are available at [Copernicus Land Monitoring Service](https://land.copernicus.eu/en/products/corine-land-cover). The SRTM GL1 30m digital elevation model can be downloaded from [OpenTopography](https://portal.opentopography.org/raster?opentopoID=OTSRTM.082015.4326.1).
